## LAB5：用户程序
### 实验目的
- 了解第一个用户进程创建过程
- 了解系统调用框架的实现机制
- 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理


### 实验内容
#### 练习1：加载应用程序并执行
- `load_icode`函数设计实现过程：
    - 创建一个新的`mm_struct`。
    - 创建一个新的PDT，将mm的pgdir设置为这个PDT的虚拟地址。
    - 读取ELF格式，检验其合法性，循环读取每一个程序段，将需要加载的段加载到内存中，设置相应段的权限。之后初始化 BSS 段，将其清零。
    - 设置用户栈。
    - 设置当前进程的mm、cr3 , 设置satp寄存器。
    - 设置trapframe，将gpr.sp指向用户栈顶，将epc设置为ELF文件的入口地址，设置status寄存器，将SSTATUS_SPP位置0，表示退出当前中断后进入用户态，将SSTATUS_SPIE位置1，表示退出当前中断后开启中断。

- 简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

在一个用户进程被ucore内核选择，实际上这个选择指的是当操作系统的调度器从就绪进程队列中选择了一个就绪进程后，通过执行进程切换，就让这个被选上的就绪进程执行了。不过还需要做一些准备包括设置中断帧等，具体如下:

    - 准备加载新的执行码
        - 清空用户态内存空间准备加载新的执行码:具体由do_execve实现。对mm进行一些判断:
            - mm不为空:说明是用户进程，设置页表为内核空间页表，目的是转入内核态。
            - mm引用数为1:意味着只有当前进程在使用这块内存。如果这个进程结束了，那么它所占用的用户空间内存和进程页表本身所占空间就没有其他进程会再使用，因此这些空间应该被释放，以便可以被其他进程使用。此时释放进程所占用户空间内存和进程页表本身所占空间，可以有效地管理和利用有限的内存资源。

    - 加载应用程序执行码与建立用户环境:包括读取ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码。主要由loadicode实现。
        - mm_create:申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化。
        - setup_pgdir:申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表的内容拷贝到此新目录表中。能够正确映射内核虚空间。
        - 解析此ELF格式的执行程序，然后调用mm_map根据执行程序说明的各个段的起始位和大小建立对应的vma结构，把vma插入到mm结构中。从而表明了用户进程的合法用户态虚拟地址空间。
        - 分配物理内存空间，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中。
        - 调用mm map设置用户栈，建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存目建立好栈的虚地址和物理地址映射关系。
        - 更新用户进程的虚拟内存空间:把mm->pgdir赋值到cr3寄存器中，更新了用户进程的虚拟内存空间
        - 建立进程的执行现场:清空进程的中断帧，重新设置进程的中断帧，使得在执行中断返回指令"iret"后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断。
    - 返回用户态执行用户进程

#### 练习2：父进程复制自己的内存空间给子进程
- 设计实现过程：【do_fork->copy_mm->dup_mmap->copy_range】

逐个内存页进行复制，首先找到父进程的页表项，然后创建一个子进程新的页表项，设置对应的权限，然后将父进程的页表项对应的内存页复制到子进程的页表项对应的内存页中，然后将子进程的页表项加入到子进程的页表中。

- 设计实现`Copy on Write`机制？
    - 资源共享:当多个任务读取同一资源时，它们共享对该资源的访问，而不是复制资源。具体来说可以通过copy_range的share参数实现，在copy_range中要根据share参数判断一下是应该直接dup还是共享。
    - 检测写操作:当一个任务试图写入共享资源时，系统需要捕获这个操作。通过内存保护硬件实现当任务试图写入一个标记为只读的内存区域时，硬件触发一个异常。可以通过定义一个新的trap类型，然后到trap.c的exception handler中对应处理。
    - 资源复制:当系统捕获到写操作时，它会分配新的内存或磁盘空间，并将原始资源的内容复制到新分配的空间中。可以调用copy_range实现。
    - 更新指针:系统将试图写入资源的任务的指针更新为指向新复制的资源，然后允许写操作继续进行。这样写操作只影响新复制的资源，而不影响其他任务看到的原始资源。

#### 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现
- 对 fork/exec/wait/exit函数的分析：
    
    系统调用都会引起用户态到内核态的切换，返回结果的方式同查是通过指定的寄存器或内存区域。
    - `fork`:fork->SYS _fork->do_fork+wakeup_proc

    进程调用 fork 系统调用，进入正常的中断处理机制，最终交由sysca11函数进行处理，在sysca11函数中，根据系统调用，交由 sys_fork函数处理，该函数进一步调用了 do_fork 函数。

    整体流程：
        - 首先检查当前总进程数目是否到达限制，如果到达限制，那么返回 E_NO_FREE_PROC
        - 调用 a11oc_proc来创建并初始化一个进程控制块
        - 调用 setup_kstack为内核进程(线程)建立栈空间、分配内核栈
        - 调用 copy_mm 拷贝或者共享内存空间
        - 调用 copy_thread 复制父进程的中断帧和上下文信息
        - 调用 get_pid()为进程分配一个PID
        - 将进程控制块加入哈希表和链表，并实现相关进程的链接
        - 返回进程的PID
    状态操作：
        - 用户态:父进程调用 fork()系统调用。
        - 内核态:内核复制父进程的所有资源(内存、文件描述符等)，创建一个新的子进程
        - 用户态:子进程从 fork 调用返回，得到一个新的进程ID(PID)，父进程也从 fork 调用返回，得到子进程的PID。

    - `exec`:SYs_exec->do_execve

    整体流程：
        - 检查进程名称的地址和长度是否合法，如果合法，那么将名称暂时保存在函数栈中，否则返回E_INVAL
        - 将cr3页表基址指向内核页表，然后实现对进程的内存管理区域的释放
        - 调用 load_icode 将代码加载进内存并建立新的内存映射关系，如果加载错误，那么调用panic报错
        - 调用 set_proc_name 重新设置进程名称。

    状态操作：
        - 用户态:进程调用 exec系统调用，加载并执行新的程序。
        - 内核态:内核加载新程序的代码和数据，并进行一些必要的初始化。
        - 用户态:新程序开始执行，原来的程序替换为新程序。

    - `wait`:SYs_wait->do_wait
    整体流程：
        - 首先检查用于保存返回码的 code_store 指针地址位于合法的范围内
        - 根据PID找到需要等待的子进程PCB，循环询问正在等待的子进程的状态，直到有子进程状态变为 ZOMBIE:
            - 如果没有需要等待的子进程，那么返回 E_BAD_PROC
            - 如果子进程正在可执行状态中，那么将当前进程休眠，在被唤醒后再次尝试
            - 如果子进程处于僵尸状态，那么释放该子进程剩余的资源，即完成回收工作。
    状态操作：
        - 用户态:父进程调用 wait 或 waitpid 系统调用等待子进程的退出
        - 内核态:如果子进程已经退出，内核返回子进程的退出状态给父进程:如果子进程尚未退出父进程被阻寨，等待子进程退出
        - 用户态:父进程得到子进程的退出状态，可以进行相应的处理。

    - `exit`:SYS_exit->exit
    整体流程：
        - 释放进程的虚拟内存空间
        - 设置当期进程状态为 PROC_ZOMBIE 即标记为僵尸进程
        - 如果父进程处于等待当期进程退出的状态，则将父进程唤醒
        - 如果当前进程有子进程，则将子进程设置为initproc的子进程，并完成子进程中处于僵尸状态的进程的最后的回收工作
        - 主动调用调度函数进行调度，选择新的进程去执行
    状态操作：
        - 用户态:进程调用 exit系统调用，通知内核准备退出。
        - 内核态:内核清理进程资源，包括释放内存、关闭文件等。
        - 用户态:进程退出，返回到父进程。


- 给出ucore中一个用户态进程的执行状态生命周期图：
```
     创建进程        +-----wait()--------RUNNING-------------+
        |            |                    ^  |              |
        |            |                    |  |              |
    alloc_page()     |                  proc_run()         exit()
        |            |                    |  |              |
        \/           |                    | \/              \/
      UNINIT-------wakeup_proc()----->RUNNABLE---exit()->ZOMBIE--父进程调用wait()
                     |                     ^                ^
                     |                     |                |
                     |               子进程调用exit()      exit()
                     |                     |                |
                     |                     |                |
                     +------wait()------>SLEEPING-----------+           

```

### 知识点
- 如何在用户态中运行程序？分配一些内存、把代码加载进来、建立一个进程，然后通过调度让这个用户进程开始执行。
- 系统调用：操作系统提供给用户程序的一些接口，让用户程序使用操作系统提供的服务（即能从U mode获取S mode）。【用户态U mode，内核态S mode（系统调用在内核态执行，使用ecall指令）】
    - `sys_fork()`：把当前的进程复制一份，创建一个子进程，原先的进程是父进程。接下来两个进程都会收到sys_fork()的返回值，如果返回0说明当前位于子进程中，返回一个非0的值（子进程的PID）说明当前位于父进程中。然后就可以根据返回值的不同，在两个进程里进行不同的处理。
    - `sys_exec()`：在当前的进程下，停止原先正在运行的程序，开始执行一个新程序。PID不变，但是内存空间要重新分配，执行的机器代码发生了改变。我们可以用fork()和exec()配合，在当前程序不停止的情况下，开始执行另一个程序。
    - `sys_exit()`：退出当前的进程。
    - `sys_wait()`：挂起当前的进程，等到特定条件满足的时候再继续执行。

    只有在Supervisor Mode才能通过ecall调用Machine Mode的OpenSBI接口，而在用户态(U Mode)就不能直接使用M mode的接口，而是要通过系统调用。

- 实验过程：
    - init_main()中建立了一个内核进程，执行函数user_main()——该进程中将执行用户线程
    - user_main()中加载存储在特定额外i之的程序exit并在user_main中开始执行（此时user_main从内核进程变为用户进程）。在user目录下存储了一些用户程序，在编译的时候放到生成的镜像里。【？】
    - 系统调用实现：在用户态进行系统调用的核心操作是，通过内联汇编进行ecall环境调用【trap前把一些信息（比如选择的系统调用 编号）传到了寄存器，之后就在tf->gpr中】。这将产生一个trap, 进入S mode进行异常处理——进入trap.c的exception_handler，调用syscall.c的syscall()【syscall.c中的函数把系统调用进一步转发给proc.c的do_exit(), do_fork()等函数】。
    ```
    static int (*syscalls[])(uint64_t arg[]) = {
        [SYS_exit]              sys_exit,
        [SYS_fork]              sys_fork,
        [SYS_wait]              sys_wait,
        [SYS_exec]              sys_exec,
        [SYS_yield]             sys_yield,
        [SYS_kill]              sys_kill,
        [SYS_getpid]            sys_getpid,
        [SYS_putc]              sys_putc,
    };
    ```
    - 到vmm.c：上下文切换实际上要借助中断处理的返回来完成,直接调用do_execve()是无法完成上下文切换的。如果是在用户态调用exec(), 系统调用的ecall产生的中断返回时， 就可以完成上下文切换。但由于目前我们在S mode下，所以不能通过ecall来产生中断。所有用ebreak产生断点中断进行处理【进入exception_handler的CAUSE_BREAKPOINT】，通过设置a7寄存器的值为10说明这不是一个普通的断点中断，而是要转发到syscall()。

    为了使得sret的时候能回到U mode（因为是从S mode的ebreak进入中断，所以正常sret会返回S mode），通过在load_icode()函数中修改SSTATUS_SPP为0达成。

    - 中断处理：每个用户进程会有两个栈，一个内核栈一个用户栈。

    - 进程退出：首先由进程本身完成大部分资源的占用内存回收工作，然后由此进程的父进程完成剩余资源占用内存的回收工作。在用户态的函数库中提供了exit函数，此函数最终访问sys_exit系统调用接口。结束进程的时候要把状态设为PROC_ZOMBIE、释放虚拟内存空间、唤醒他爹来结束它、把所有子进程交给initproc（放在第一个）

    - 如果mm不为空，说明是用户进程。

    - proc_init()中创建“idle”进程，然后调用kernel_thread创建init_main进程；kernel_thread中设置了tf的值，并调用do_fork创建。之后在schedule()的作用下，current进程将转为init_main()，而init_main()中，又调用kernel_thread创建user_main()的用户线程。接着init_main()调用do_wait函数。满足条件后调用schedule()就会选中user_main执行。而user_main()中，调用KERNEL_EXECVE(exit)，即kern_execve("exit", _binary_obj___user_exit_out_start,_binary_obj___user_exit_out_size)。kernel_execve中又通过内联汇编（其中sysexec宏被放入a0寄存器）+ebreak+a7设置为特殊值的方法在exception_handler中调用syscall()。在syscall()中，依次提取之前内联汇编存下的参数值，并据此判断要使用哪个系统调用接口（根据a0判断要调用sys_exec()函数）在sys_exec中又调用do_execve()。在do_execve()中，设置mm、name，调用load_icode()把新的二进制程序加载到内存中、并设置SPP使后续直接返回用户态（需在用户态下执行加载的应用程序）。然后就从syscall()返回，根据SPP等实现上下文切换返回用户态。